#include "tripch.h"
#include "OpenGLCommandList.h"
#include "OpenGLTexture.h"
#include "OpenGLSampler.h"
#include "OpenGLMesh.h"
#include "OpenGLPipelineState.h"
#include "OpenGLState.h"
#include "OpenGLShaderBindingLayout.h"

namespace Tridium {

    bool OpenGLCommandList::SetGraphicsCommands( const RHIGraphicsCommandBuffer& a_CmdBuffer )
    {
		// Execute the commands
		for ( const RHICommand& cmd : a_CmdBuffer.Commands )
		{
			switch ( cmd.Type() )
			{
			#define PerformCmd( _CmdType ) case ERHICommandType::_CmdType: _CmdType( cmd.Get<ERHICommandType::_CmdType>() ); break
				PerformCmd( SetShaderBindingLayout );
				PerformCmd( SetShaderInput );
				PerformCmd( ResourceBarrier );
				PerformCmd( SetGraphicsPipelineState );
				PerformCmd( SetRenderTargets );
				PerformCmd( ClearRenderTargets );
				PerformCmd( SetScissors );
				PerformCmd( SetViewports );
				PerformCmd( SetIndexBuffer );
				PerformCmd( SetVertexBuffer );
				PerformCmd( SetPrimitiveTopology );
				PerformCmd( Draw );
				PerformCmd( DrawIndexed );
				PerformCmd( SetComputePipelineState );
				PerformCmd( DispatchCompute );
				PerformCmd( DispatchComputeIndirect );
				PerformCmd( FenceSignal );
				PerformCmd( FenceWait );
				PerformCmd( Execute );
				default: ASSERT_LOG( false, "Invalid command type '{0}' being used in SetGraphicsCommands", RHI::GetCommandName( cmd.Type() ) ); break;
			}
		}

		OpenGL3::DeleteBuffers( m_UBOs.Size(), m_UBOs.Data() );
		m_UBOs.Clear();

		return true;
    }

	bool OpenGLCommandList::SetComputeCommands( const RHIComputeCommandBuffer& a_CmdBuffer )
	{
		return false;
	}

	void OpenGLCommandList::SetShaderBindingLayout( const RHICommand::SetShaderBindingLayout& a_Data )
	{
		if ( a_Data.SBL == nullptr ) [[unlikely]]
		{
			ASSERT_LOG( false, "Attempting to bind a null shader binding layout!" );
			return;
		}

		GLState::s_BoundSBL = SharedPtrCast<OpenGLShaderBindingLayout>( a_Data.SBL->shared_from_this() );
	}

	void OpenGLCommandList::SetShaderInput( const RHICommand::SetShaderInput& a_Data )
	{
		SharedPtr<OpenGLShaderBindingLayout> sbl = GLState::s_BoundSBL.lock();
		if ( !ASSERT_LOG( sbl, "No shader binding layout bound!" ) )
			return;

		SharedPtr<OpenGLGraphicsPipelineState> gpso = GLState::s_BoundGraphicsPSO.lock();
		if ( !ASSERT_LOG( gpso, "No graphics pipeline state bound!" ) )
			return;

		const RHIShaderBinding& binding = sbl->GetDescriptor()->GetBindingFromName( a_Data.NameHash );
		const GLint uniformLocation = gpso->TryGetUniformLocation( binding.Name );
		if ( uniformLocation < 0 )
		{
			LOG( LogCategory::RHI, Error, "Uniform '{0}' not found in shader while setting shader input", binding.Name.String() );
			return;
		}

		switch ( binding.BindingType )
		{
		case ERHIShaderBindingType::Constant:
		{
			if ( binding.IsInlined() )
			{
				// Annoyingly, the PUSH_CONSTANT generated by the DXCompiler creats a UBO.

				GLState::BindVertexArray( 0 ); // Unbind the VAO so we can bind the UBO

				GLuint ubo = m_UBOs.EmplaceBack();
				OpenGL3::GenBuffers( 1, &ubo );
				OpenGL3::BindBuffer( GL_UNIFORM_BUFFER, ubo );
				OpenGL3::BufferData( GL_UNIFORM_BUFFER, binding.GetSizeInBytes(), a_Data.Payload.InlineData, GL_STATIC_DRAW );
				OpenGL3::BindBufferBase( GL_UNIFORM_BUFFER, uniformLocation, ubo );

#if 0


				size_t offset = 0;
				int32_t bindingIndex = -1;
				for ( const auto& [name, tensorType] : binding.InlinedConstant->Tensors )
				{
					bindingIndex++;

					const int32_t wordSize = tensorType.GetSizeInBytes() >> 2;
					const ERHIDataType dataType = tensorType.ElementType;
					const GLint bindSlot = uniformLocation + bindingIndex;

					const float* asFloats = reinterpret_cast<const float*>( a_Data.Payload.InlineData[offset] );
					const double* asDoubles = reinterpret_cast<const double*>( a_Data.Payload.InlineData[offset] );
					const int32_t* asInt32s = reinterpret_cast<const int32_t*>( a_Data.Payload.InlineData[offset] );
					const uint32_t* asUint32s = reinterpret_cast<const uint32_t*>( a_Data.Payload.InlineData[offset] );

					offset += wordSize;

					switch ( wordSize )
					{
					case 1:
						switch ( dataType )
						{
						case ERHIDataType::Float32: OpenGL3::Uniform1fv( bindSlot, 1, asFloats ); break;
						case ERHIDataType::Float64: OpenGL4::Uniform1dv( bindSlot, 1, asDoubles ); break;
						case ERHIDataType::Int32:   OpenGL2::Uniform1iv( bindSlot, 1, asInt32s ); break;
						case ERHIDataType::UInt32:  OpenGL3::Uniform1uiv( bindSlot, 1, asUint32s ); break;
						}
						break;

					case 2: // Vector2
						switch ( dataType )
						{
						case ERHIDataType::Float32: OpenGL2::Uniform2fv( bindSlot, 1, asFloats ); break;
						case ERHIDataType::Float64: OpenGL4::Uniform2dv( bindSlot, 1, asDoubles ); break;
						case ERHIDataType::Int32:   OpenGL2::Uniform2iv( bindSlot, 1, asInt32s ); break;
						case ERHIDataType::UInt32:  OpenGL3::Uniform2uiv( bindSlot, 1, asUint32s ); break;
						}
						break;

					case 3: // Vector3
						switch ( dataType )
						{
						case ERHIDataType::Float32: OpenGL3::Uniform3fv( bindSlot, 1, asFloats ); break;
						case ERHIDataType::Float64: OpenGL4::Uniform3dv( bindSlot, 1, asDoubles ); break;
						case ERHIDataType::Int32:   OpenGL2::Uniform3iv( bindSlot, 1, asInt32s ); break;
						case ERHIDataType::UInt32:  OpenGL3::Uniform3uiv( bindSlot, 1, asUint32s ); break;
						}
						break;

					case 4: // Vector4
						switch ( dataType )
						{
						case ERHIDataType::Float32: OpenGL3::Uniform4fv( bindSlot, 1, asFloats ); break;
						case ERHIDataType::Float64: OpenGL4::Uniform4dv( bindSlot, 1, asDoubles ); break;
						case ERHIDataType::Int32:   OpenGL2::Uniform4iv( bindSlot, 1, asInt32s ); break;
						case ERHIDataType::UInt32:  OpenGL3::Uniform4uiv( bindSlot, 1, asUint32s ); break;
						}
						break;

					case 9: // Matrix3
						switch ( dataType )
						{
						case ERHIDataType::Float32: OpenGL2::UniformMatrix3fv( bindSlot, 1, GL_FALSE, asFloats ); break;
						case ERHIDataType::Float64: OpenGL4::UniformMatrix3dv( bindSlot, 1, GL_FALSE, asDoubles ); break;
						}
						break;

					case 16: // Matrix4
						switch ( dataType )
						{
						case ERHIDataType::Float32: OpenGL2::UniformMatrix4fv( bindSlot, 1, GL_FALSE, asFloats ); break;
						case ERHIDataType::Float64: OpenGL4::UniformMatrix4dv( bindSlot, 1, GL_FALSE, asDoubles ); break;
						}
						break;
					}
				}
#endif
			}
			else
			{
				// Referenced constant
				NOT_IMPLEMENTED;
			}
			break;
		}
		case ERHIShaderBindingType::Mutable:
			break;
		case ERHIShaderBindingType::Storage:
			break;
		case ERHIShaderBindingType::Texture:
		{
			ASSERT_LOG( false, "OpenGL requires textures and samplers to be combined in the shader! - Use a Texture binding instead and set the sampler in the texture." );
			break;
		}
		case ERHIShaderBindingType::RWTexture:
			break;
		case ERHIShaderBindingType::Sampler:
		{
			ASSERT_LOG( false, "OpenGL requires textures and samplers to be combined in the shader! - Use a Texture binding instead and set the sampler in the texture." );
			break;
		}
		case ERHIShaderBindingType::CombinedSampler:
		{
			if ( !a_Data.Payload.IsReference ) [[unlikely]]
			{
				ASSERT_LOG( false, "Invalid shader input - a Texture can not be inlined!" );
				break;
			}

			// The names of Combined Samplers in GLSL have been set to the Texture name ( from HLSL )
			// So we can just bind the texture and sampler together
			OpenGLTexture* texture = static_cast<OpenGLTexture*>( a_Data.Payload.References[0] );
			if ( !( texture->Sampler ) )
			{
				ASSERT_LOG( false, "Texture has no sampler! - OpenGL requires Textures to have a Sampler, you can set the sampler on the RHITexture." );
				break;
			}

			OpenGLSampler* sampler = texture->Sampler->As<OpenGLSampler>();
			OpenGL4::BindTextureUnit( uniformLocation, texture->GetGLHandle() );
			OpenGL4::BindSampler( uniformLocation, sampler->GetGLHandle() );
			break;
		}
		default:
			ASSERT_LOG( false, "Unknown shader binding type!" );
			return;
		}
	}

	void OpenGLCommandList::ResourceBarrier( const RHICommand::ResourceBarrier& a_Data )
	{
		// TODO: Implement
	}

	void OpenGLCommandList::SetGraphicsPipelineState( const RHICommand::SetGraphicsPipelineState& a_Data )
	{
		if ( a_Data.PSO == nullptr )
		{
			GLState::s_BoundGraphicsPSO.reset();
			return;
		}

		OpenGLGraphicsPipelineState* pso = a_Data.PSO->As<OpenGLGraphicsPipelineState>();
		if ( !GLState::s_BoundGraphicsPSO.expired() && GLState::s_BoundGraphicsPSO.lock().get() == pso )
		{
			return;
		}

		GLState::s_BoundGraphicsPSO = SharedPtrCast<OpenGLGraphicsPipelineState>( a_Data.PSO->shared_from_this() );

		// Bind the shader program
		GLState::BindProgram( pso->GetShaderProgramID() );

		// Bind the VAO
		GLState::BindVertexArray( pso->GetVAO() );

		// Set the rasterizer state
	}

	void OpenGLCommandList::SetRenderTargets( const RHICommand::SetRenderTargets& a_Data )
	{
		if ( !a_Data.RTV[0] )
		{
			GLState::BindFBO( 0 );
			OpenGL3::BindFramebuffer( GL_FRAMEBUFFER, 0 );
			return;
		}

		if ( !GLState::s_FBO )
		{
			OpenGL3::GenFramebuffers( 1, &GLState::s_FBO );
		}

		GLState::BindFBO( GLState::s_FBO );

		const GLchar* label = "Asher's FBO";
		OpenGL4::ObjectLabel( GL_FRAMEBUFFER, GLState::s_FBO, strlen( label ), label );

		TODO( "Do we want to support this?" );
		constexpr int mipmapLevelToRenderTo = 0;

		// Bind the render targets
		for ( size_t i = 0; i < a_Data.RTV.Size(); ++i )
		{
			OpenGLTexture* rtv = a_Data.RTV[i]->As<OpenGLTexture>();
			OpenGL3::FramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, rtv->GetGLHandle(), mipmapLevelToRenderTo );
		}

		// Bind the depth stencil target
		if ( a_Data.DSV )
		{
			OpenGLTexture* dsv = a_Data.DSV->As<OpenGLTexture>();
			const bool hasStencil = dsv->GetDescriptor()->Format == ERHITextureFormat::D24S8;
			OpenGL3::FramebufferTexture2D( GL_FRAMEBUFFER, hasStencil ? GL_DEPTH_STENCIL_ATTACHMENT : GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, dsv->GetGLHandle(), mipmapLevelToRenderTo );
		}

		ENSURE( OpenGL3::CheckFramebufferStatus( GL_FRAMEBUFFER ) == GL_FRAMEBUFFER_COMPLETE );

		// Set the draw buffers
		constexpr GLenum drawBuffers[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT4, GL_COLOR_ATTACHMENT5, GL_COLOR_ATTACHMENT6, GL_COLOR_ATTACHMENT7 };
		OpenGL3::DrawBuffers( a_Data.RTV.Size(), drawBuffers );
	}

	void OpenGLCommandList::ClearRenderTargets( const RHICommand::ClearRenderTargets& a_Data )
	{
		if ( a_Data.RTV.Size() > 0 )
		{
			const Color& colour = a_Data.ClearColor;
			OpenGL4::ClearColor( colour.r, colour.g, colour.b, colour.a );
			GLbitfield clearMask = GL_COLOR_BUFFER_BIT;
			clearMask |= a_Data.DepthBit ? GL_DEPTH_BUFFER_BIT : 0;
			clearMask |= a_Data.StencilBit ? GL_STENCIL_BUFFER_BIT : 0;
			OpenGL4::Clear( clearMask );

			TODO( "Support for multiple render targets" );
		}
	}

	void OpenGLCommandList::SetScissors( const RHICommand::SetScissors& a_Data )
	{
		for ( uint32_t i = 0; i < a_Data.Rects.Size(); ++i )
		{
			const ScissorRect& scissor = a_Data.Rects[i];
			const GLint left = scissor.Left;
			const GLint bottom = scissor.Bottom;
			const GLsizei width = scissor.Right - scissor.Left;
			const GLsizei height = scissor.Bottom - scissor.Top;
			OpenGL4::ScissorIndexed( i, left, bottom, width, height );
		}
	}

	void OpenGLCommandList::SetViewports( const RHICommand::SetViewports& a_Data )
	{
		OpenGL1::Viewport( a_Data.Viewports[0].X, a_Data.Viewports[0].Y, a_Data.Viewports[0].Width, a_Data.Viewports[0].Height );
		//for ( uint32_t i = 0; i < a_Data.Viewports.Size(); ++i )
		//{
		//	const Viewport& vp = a_Data.Viewports[i];
		//	OpenGL4::ViewportIndexedf( i, vp.X, vp.Y, vp.Width, vp.Height );
		//}
	}

	void OpenGLCommandList::SetIndexBuffer( const RHICommand::SetIndexBuffer& a_Data )
	{
	}

	void OpenGLCommandList::SetVertexBuffer( const RHICommand::SetVertexBuffer& a_Data )
	{
		if ( a_Data.VBO == nullptr )
		{
			GLState::s_BoundVBO = 0;
		}
		else
		{
			GLState::s_BoundVBO = a_Data.VBO->As<OpenGLVertexBuffer>()->GetGLHandle();
		}

		if ( GLState::s_BoundVBO && GLState::s_BoundIBO )
		{
			// Bind the VAO
			const GLuint vao = GLState::GetOrEmplaceCachedVAO( GLState::s_BoundVBO, GLState::s_BoundIBO );
			GLState::BindVertexArray( vao );
			OpenGL1::BindBuffer( GL_ARRAY_BUFFER, GLState::s_BoundVBO );
			OpenGL1::BindBuffer( GL_ELEMENT_ARRAY_BUFFER, GLState::s_BoundIBO );

			GLState::s_BoundGraphicsPSO.lock()->ApplyVertexLayoutToVAO( vao );
		}
		else if ( GLState::s_BoundVBO )
		{
			// Bind the VAO
			const GLuint vao = GLState::GetOrEmplaceCachedVAO( GLState::s_BoundVBO );
			GLState::BindVertexArray( vao );
			OpenGL1::BindBuffer( GL_ARRAY_BUFFER, GLState::s_BoundVBO );

			GLState::s_BoundGraphicsPSO.lock()->ApplyVertexLayoutToVAO( vao );
		}
		else
		{
			GLState::BindVertexArray( 0 );
		}
	}

	void OpenGLCommandList::SetPrimitiveTopology( const RHICommand::SetPrimitiveTopology& a_Data )
	{
		GLState::s_BoundPrimitiveTopology = ToOpenGL::GetTopology( a_Data.Topology );
	}

	void OpenGLCommandList::Draw( const RHICommand::Draw& a_Data )
	{
		OpenGL1::DrawArrays( GLState::s_BoundPrimitiveTopology, a_Data.VertexStart, a_Data.VertexCount );
	}

	void OpenGLCommandList::DrawIndexed( const RHICommand::DrawIndexed& a_Data )
	{
		TODO( "Fix index start i fink" );
		OpenGL2::DrawElements( GLState::s_BoundPrimitiveTopology, a_Data.IndexCount, GL_UNSIGNED_INT, reinterpret_cast<const void*>( a_Data.IndexStart ) );
	}

	void OpenGLCommandList::SetComputePipelineState( const RHICommand::SetComputePipelineState& a_Data )
	{
	}

	void OpenGLCommandList::DispatchCompute( const RHICommand::DispatchCompute& a_Data )
	{
	}

	void OpenGLCommandList::DispatchComputeIndirect( const RHICommand::DispatchComputeIndirect& a_Data )
	{
	}

	void OpenGLCommandList::FenceSignal( const RHICommand::FenceSignal& a_Data )
	{
	}

	void OpenGLCommandList::FenceWait( const RHICommand::FenceWait& a_Data )
	{
	}

	void OpenGLCommandList::Execute( const RHICommand::Execute& a_Data )
	{
	}

} // namespace Tridium
